From stdpp Require Import gmap base relations.
From iris Require Import prelude.
From semantics.lib Require Export facts.
From semantics.ts.systemf_mu Require Import lang notation types tactics pure parallel_subst.
From Equations Require Export Equations.

(** * Logical relation for SystemF + recursive types *)

Implicit Types
  (Œî : nat)
  (Œì : typing_context)
  (v : val)
  (Œ± : var)
  (e : expr)
  (A : type).


(** ** Definition of the logrel *)
(** A semantic type consists of a value-predicate parameterized over a step-index,
   a proof of closedness, and a proof of downwards-closure wrt step-indices. *)
Record sem_type := mk_ST {
  sem_type_car :> nat ‚Üí val ‚Üí Prop;
  sem_type_closed_val k v : sem_type_car k v ‚Üí is_closed [] (of_val v);
  sem_type_mono : ‚àÄ k k' v, sem_type_car k v ‚Üí k' ‚â§ k ‚Üí sem_type_car k' v
  }.

(** Two tactics we will use later on.
  [pose_sem_type P as N] defines a semantic type at name [N] with the value predicate [P].
 *)
(* slightly complicated formulation to make the proof term [p] opaque and prevent it from polluting the context *)
Tactic Notation "pose_sem_type" uconstr(P) "as" ident(N) :=
  let p := fresh "__p" in
  let p2 := fresh "__p2" in
  unshelve refine ((Œª p p2, let N := (mk_ST P p p2) in _) _ _); first (simpl in p, p2); cycle 1.
Tactic Notation "specialize_sem_type" constr(S) "with" uconstr(P) "as" ident(N) :=
  pose_sem_type P as N; last specialize (S N).

(** We represent type variable assignments [Œ¥] as functions [f] into semantic types.
  The variable [#n] (in De Bruijn representation) is mapped to [f n].
 *)
Definition tyvar_interp := var ‚Üí sem_type.
Implicit Types
  (Œ¥ : tyvar_interp)
  (œÑ : sem_type)
.

(**
  In Coq, we need to make argument why the logical relation is well-defined precise:
  (for Coq, that means: we need to show that the recursion is terminating).

  Adding in the recursion over step-indices makes the termination argument slightly more complicated:
    we now have a mutual recursion over types, step-indices, and the case of the logrel (the expression relation is defined in terms of the value relation).

  To make this formal, we define a well-founded relation that allows to either decrease the step-index, the type, or switch from the expression case to the value case for recursive calls.
  We define size measures for for all three of these things, and then combine them into a big lexicographic ordering [term_rel].
 *)
Equations type_size (A : type) : nat :=
  type_size Int := 1;
  type_size Bool := 1;
  type_size Unit := 1;
  type_size (A ‚Üí B) := type_size A + type_size B + 1;
  type_size (#Œ±) := 1;
  type_size (‚àÄ: A) := type_size A + 2;
  type_size (‚àÉ: A) := type_size A + 2;
  type_size (A √ó B) := type_size A + type_size B + 1;
  type_size (A + B) := max (type_size A) (type_size B) + 1;
  type_size (Œº: A) := type_size A + 2
.
(* [ltof A R] defines a well-founded measure on type [A] by using a mapping [R] from [A] to [nat]
  (it lifts the < relation on natural numbers to [A]) *)
Definition type_lt := ltof type type_size.
#[local] Instance type_lt_wf : WellFounded type_lt.
Proof. apply well_founded_ltof. Qed.

Inductive type_case : Set :=
  | expr_case | val_case.
Definition type_case_size (c : type_case) : nat :=
  match c with | expr_case => 1 | val_case => 0 end.
Definition type_case_lt := ltof type_case type_case_size.
#[local] Instance type_case_lt_wf : WellFounded type_case_lt.
Proof. apply well_founded_ltof. Qed.

Definition term_rel := Subterm.lexprod nat (type * type_case) lt (Subterm.lexprod type type_case type_lt type_case_lt).
#[local] Instance term_rel_wf : WellFounded term_rel. apply _. Qed.

(** *** The logical relation *)
(** Since the relation is step-indexed now, and the argument that the case for recursive types is well-formed
  fundamentally requires decreasing the step-index, we also need to convince Equations that this definition is well-formed!
   We do this by providing a well-founded termination relation [term_rel] that decreases for each recursive call.
 *)
Equations type_interp (c : type_case) (t : type) Œ¥ (k : nat) (v : match c with val_case => val | expr_case => expr end) : Prop
  by wf (k, (t, c)) term_rel := {

  type_interp val_case Int Œ¥ k v =>
    ‚àÉ z : Z, v = #z ;
  type_interp val_case Bool Œ¥ k v =>
    ‚àÉ b : bool, v = #b ;
  type_interp val_case Unit Œ¥ k v =>
    v = #LitUnit ;
  type_interp val_case (A √ó B) Œ¥ k v =>
    ‚àÉ v1 v2 : val, v = (v1, v2)%V ‚àß type_interp val_case A Œ¥ k v1 ‚àß type_interp val_case B Œ¥ k v2;
  type_interp val_case (A + B) Œ¥ k v =>
    (‚àÉ v' : val, v = InjLV v' ‚àß type_interp val_case A Œ¥ k v') ‚à®
    (‚àÉ v' : val, v = InjRV v' ‚àß type_interp val_case B Œ¥ k v');

  type_interp val_case (A ‚Üí B) Œ¥ k v =>
    ‚àÉ x e, v = LamV x e ‚àß is_closed (x :b: nil) e ‚àß
      (* Slightly weird formulation: for down-closure, we want to quantify over all k' ‚â§ k --
        but with that formulation, the termination checker will not be able to see that k' will really be smaller!
         Thus, we quantify over the difference kd and subtract *)
      ‚àÄ v' kd,
        type_interp val_case A Œ¥ (k - kd) v' ‚Üí
        type_interp expr_case B Œ¥ (k - kd) (subst' x (of_val v') e);
  type_interp val_case (#Œ±) Œ¥ k v =>
    (Œ¥ Œ±).(sem_type_car) k v;
  type_interp val_case (‚àÄ: A) Œ¥ k v =>
    ‚àÉ e, v = TLamV e ‚àß is_closed [] e ‚àß
      ‚àÄ œÑ, type_interp expr_case A (œÑ .: Œ¥) k e;
  type_interp val_case (‚àÉ: A) Œ¥ k v =>
    ‚àÉ v', v = PackV v' ‚àß
      ‚àÉ œÑ : sem_type, type_interp val_case A (œÑ .: Œ¥) k v';
  (** Recursive type case *)
  (** Defined with two cases: ordinarily, we might require [k > 0] in the body as a guard for the recursive call,
     but this does not count as a proper guard for termination for Coq -- therefore we handle the 0-case separately.
   *)
  type_interp val_case (Œº: A) Œ¥ (S k) v =>
    ‚àÉ v', v = (roll v')%V ‚àß is_closed [] v' ‚àß ‚àÄ kd, type_interp val_case (A.[Œº: A/]%ty) Œ¥ (k - kd) v';
  type_interp val_case (Œº: A) Œ¥ 0 v =>
    ‚àÉ v', v = (roll v')%V ‚àß is_closed [] v';

  type_interp expr_case t Œ¥ k e =>
    ‚àÄ e' n, n < k ‚Üí red_nsteps n e e' ‚Üí ‚àÉ v, to_val e' = Some v ‚àß type_interp val_case t Œ¥ (k - n) v
}.

(** Proving that the arguments are decreasing for recursive calls is a bit more messy now, but it's mostly systematic.
  Therefore we provide a simple automation tactic that will also become useful a few times below.
*)
Ltac dsimpl :=
  repeat match goal with
  | |- term_rel (?k, _) (?k, _) =>
      (* step-index is not decreasing, go right *)
      right
  | |- term_rel (?k1, _) (?k2, _) =>
      (* use [lia] to decide where to go *)
      destruct (decide (k1 < k2)) as [ ? | ?]; [left; lia | assert (k1 = k2) as -> by lia; right]
  | |- Subterm.lexprod type type_case _ _ (?t, _) (?t, _) =>
      (* type is not decreasing, go right *)
      right
  | |- Subterm.lexprod type type_case _ _ (_, ?a) (_, ?a) =>
      (* type case is not decreasing, go left *)
      left
  | |- term_rel (_, _) (_, _) =>
      (* branch non-deterministically and try to solve the remaining goal *)
      first [left; solve [dsimpl] | right; solve [dsimpl]]
  | |- Subterm.lexprod type type_case  _ _ _ _ =>
      (* branch non-deterministically *)
      first [left; solve [dsimpl] | right; solve [dsimpl]]
  | _ =>
      (* try to solve a leaf, i.e. a [type_lt], [type_case_lt] or [lt] goal *)
      unfold type_case_lt, type_lt, ltof; simp type_size; simpl; try lia
  end.
(** The tactic solves all of Equations' obligations for showing that the argument decreases. *)
Solve Obligations with (intros; dsimpl).

(** *** Value relation and expression relation *)
Definition sem_val_rel A Œ¥ k v := type_interp val_case A Œ¥ k v.
Definition sem_expr_rel A Œ¥ k e := type_interp expr_case A Œ¥ k e.

Notation ùí± := (type_interp val_case).
Notation ‚Ñ∞ := (type_interp expr_case).

Lemma val_rel_is_closed v Œ¥ k A:
  ùí± A Œ¥ k v ‚Üí is_closed [] (of_val v).
Proof.
  induction A as [ | | | | | A IHA | | A IH1 B IH2 | A IH1 B IH2 | A IHA] in k, v, Œ¥ |-*; simp type_interp.
  - by eapply sem_type_closed_val.
  - intros [z ->]. done.
  - intros [b ->]. done.
  - intros ->. done.
  - intros (e & -> & ? & _). done.
  - intros (v' & -> & (œÑ & Hinterp)). simpl. by eapply IHA.
  - intros (x & e & -> & ? & _). done.
  - intros (v1 & v2 & -> & ? & ?). simpl; apply andb_True; split; eauto.
  - intros [(v' & -> & ?) | (v' & -> & ?)]; simpl; eauto.
  - destruct k; simp type_interp.
    + intros (v' & -> & ?); done.
    + intros (v' & -> & ? & Ha); done.
Qed.


(** This is the Value Inclusion lemma from the lecture notes *)
Lemma sem_val_expr_rel A Œ¥ k v :
  ùí± A Œ¥ k v ‚Üí ‚Ñ∞ A Œ¥ k (of_val v).
Proof.
  simp type_interp. intros Hv e' n Hn [-> ->]%nsteps_val_inv.
  rewrite to_of_val. eexists; split; first done.
  replace (k - 0) with k by lia. done.
Qed.
Lemma sem_val_expr_rel' A Œ¥ k v e:
  to_val e = Some v ‚Üí
  ùí± A Œ¥ k v ‚Üí ‚Ñ∞ A Œ¥ k e.
Proof.
  intros <-%of_to_val. apply sem_val_expr_rel.
Qed.

Lemma sem_expr_rel_zero_trivial A Œ¥ e :
  ‚Ñ∞ A Œ¥ 0 e.
Proof.
  simp type_interp. intros ???. lia.
Qed.

Lemma sem_expr_rel_of_val A Œ¥ k v :
  k > 0 ‚Üí ‚Ñ∞ A Œ¥ k (of_val v) ‚Üí ùí± A Œ¥ k v.
Proof.
  simp type_interp.
  intros Hk He. destruct (He (of_val v) 0 ltac:(lia)) as (v' & Hv & Hvr).
  { split; first constructor. apply val_irreducible. rewrite to_of_val. eauto. }
  rewrite to_of_val in Hv. injection Hv as [= <-].
  replace k with (k - 0) by lia. done.
Qed.


(** *** Downwards closure wrt step-index *)
(** Formally proving that the expression and value relations are downwards-closed wrt the step-index
    (see the lemmas [val_rel_mono] and [expr_rel_mono] below) is slightly involved:
    Intuitively, we'd like to do an inductive argument, since the "base cases" (Int, Bool, etc.) of the
    relation are trivially downwards-closed and the other cases inductively preserve this fact.
    However, since the relation is defined via recursion on both types and the step-index, we need to
    do an induction on both simultaneously.

    For that, we do a well-founded induction with the termination relation [term_rel_wf] we gave to prove
    well-formedness of the logical relation.
    We can use the inductive hypothesis whenever either the type or the step-index decreases, or we switch from
    the expression case to the value case.
 *)
Lemma type_interp_mono : ‚àÄ '(k, (A, c)) Œ¥ k' x, k' ‚â§ k ‚Üí type_interp c A Œ¥ k x ‚Üí type_interp c A Œ¥ k' x.
Proof.
  eapply (well_founded_ind (R := term_rel) term_rel_wf).
  intros (k & A & []) IH Œ¥ k'.
  { (* expression rel *)
    intros e Hk He. simp type_interp in He. simp type_interp. intros e' n Hn Hred.
    destruct (He e' n ltac:(lia) Hred) as (v & Hval & Hv).
    exists v. split; first done.
    eapply (IH (k-n, (A, val_case))); [ | lia | done].
    (* show that the induction is decreasing *)
    dsimpl.
  }
  intros v Hk Hv.
  destruct A as [x | | | | A | A | A B | A B | A B | A ]; simp type_interp; simp type_interp in Hv.
  - (* var case *)
    by eapply sem_type_mono.
  - (* universal case *)
    destruct Hv as (e & -> & ? & Hv).
    exists e. split_and!; [done.. | ]. intros œÑ.
    eapply (IH (k, (A, expr_case))); [ dsimpl | done | done].
  - (* existential case *)
    destruct Hv as (v' & -> & (œÑ & Hv)). exists v'. split; first done.
    exists œÑ. eapply (IH (k, (A, _))); [ dsimpl | done..].
  - (* fun case *)
    destruct Hv as (x & e & -> & ? & Hv). exists x, e. split_and!; [done..| ].
    intros v' kd Hv'.
    (* slightly tricky due to the contravariant recursive occurrence *)
    set (kd' := k - k').
    specialize (Hv v' (kd + kd')).
    replace (k - (kd + kd')) with (k' - kd) in Hv by lia.
    eapply (IH (k' - kd, (B, expr_case))); [ | lia | by eapply Hv].
    destruct (decide (k' - kd < k)) as [ ? | ?]; first (left; lia).
    assert (k' - kd = k) as -> by lia. dsimpl.
  - (* pair case *)
    destruct Hv as (v1 & v2 & -> & Hv1 & Hv2).
    exists v1, v2. split_and!; first done.
    all: eapply (IH (k, (_, _))); [ dsimpl | done..].
  - (* sum case *)
    destruct Hv as [(v' & -> & Hv) | (v' & -> & Hv)]; [ left | right].
    all: exists v'; split; first done.
    all: eapply (IH (k, (_, _))); [ dsimpl | done..].
  - (* rec case *)
    destruct k; simp type_interp in Hv.
    { assert (k' = 0) as -> by lia. simp type_interp. }
    destruct Hv as (v' & -> & ? & Hv).
    destruct k' as [ | k']; simp type_interp.
    { eauto. }
    exists v'. split_and!; [ done.. | ].
    intros kd.
    (* here we crucially use that we can decrease the index *)
    eapply (IH (k - kd, (A.[(Œº: A)%ty/], val_case))); [ | lia | done].
    left. lia.
Qed.

(** We can now derive the two desired lemmas *)
Lemma val_rel_mono A Œ¥ k k' v : k' ‚â§ k ‚Üí ùí± A Œ¥ k v ‚Üí ùí± A Œ¥ k' v.
Proof. apply (type_interp_mono (k, (A, val_case))). Qed.
Lemma expr_rel_mono A Œ¥ k k' e : k' ‚â§ k ‚Üí ‚Ñ∞ A Œ¥ k e ‚Üí ‚Ñ∞ A Œ¥ k' e.
Proof. apply (type_interp_mono (k, (A, expr_case))). Qed.


(** Interpret a syntactic type *)
Program Definition interp_type A Œ¥ : sem_type := {|
  sem_type_car := ùí± A Œ¥;
|}.
Next Obligation. by eapply val_rel_is_closed. Qed.
Next Obligation. by eapply val_rel_mono. Qed.

(** Semantic typing of contexts *)
Implicit Types
  (Œ∏ : gmap string expr).

(** Context relation *)
Inductive sem_context_rel (Œ¥ : tyvar_interp) (k : nat) : typing_context ‚Üí (gmap string expr) ‚Üí Prop :=
  | sem_context_rel_empty : sem_context_rel Œ¥ k ‚àÖ ‚àÖ
  | sem_context_rel_insert Œì Œ∏ v x A :
    ùí± A Œ¥ k v ‚Üí
    sem_context_rel Œ¥ k Œì Œ∏ ‚Üí
    sem_context_rel Œ¥ k (<[x := A]> Œì) (<[x := of_val v]> Œ∏).

Notation ùí¢ := sem_context_rel.

Lemma sem_context_rel_vals {Œ¥ k Œì Œ∏ x A} :
  sem_context_rel Œ¥ k Œì Œ∏ ‚Üí
  Œì !! x = Some A ‚Üí
  ‚àÉ e v, Œ∏ !! x = Some e ‚àß to_val e = Some v ‚àß ùí± A Œ¥ k v.
Proof.
  induction 1 as [|Œì Œ∏ v y B Hvals Hctx IH].
  - naive_solver.
  - rewrite lookup_insert_Some. intros [[-> ->]|[Hne Hlook]].
    + do 2 eexists. split; first by rewrite lookup_insert.
      split; first by eapply to_of_val. done.
    + eapply IH in Hlook as (e & w & Hlook & He & Hval).
      do 2 eexists; split; first by rewrite lookup_insert_ne.
      split; first done. done.
Qed.

Lemma sem_context_rel_subset Œ¥ k Œì Œ∏ :
  ùí¢ Œ¥ k Œì Œ∏ ‚Üí dom Œì ‚äÜ dom Œ∏.
Proof.
  intros Hctx. apply elem_of_subseteq. intros x (A & Hlook)%elem_of_dom.
  eapply sem_context_rel_vals in Hlook as (e & v & Hlook & Heq & Hval); last done.
  eapply elem_of_dom; eauto.
Qed.

Lemma sem_context_rel_dom_eq Œ¥ k Œì Œ∏ :
  ùí¢ Œ¥ k Œì Œ∏ ‚Üí dom Œì = dom Œ∏.
Proof.
  induction 1 as [ | ??????? IH].
  - rewrite !dom_empty //.
  - rewrite !dom_insert IH //.
Qed.

Lemma sem_context_rel_closed Œ¥ k Œì Œ∏:
  ùí¢ Œ¥ k Œì Œ∏ ‚Üí subst_is_closed [] Œ∏.
Proof.
  induction 1 as [ | Œì Œ∏ v x A Hv Hctx IH]; rewrite /subst_is_closed.
  - naive_solver.
  - intros y e. rewrite lookup_insert_Some.
    intros [[-> <-]|[Hne Hlook]].
    + by eapply val_rel_is_closed.
    + eapply IH; last done.
Qed.

Lemma sem_context_rel_mono Œì Œ¥ k k' Œ∏ :
  k' ‚â§ k ‚Üí ùí¢ Œ¥ k Œì Œ∏ ‚Üí ùí¢ Œ¥ k' Œì Œ∏.
Proof.
  intros Hk. induction 1 as [|Œì Œ∏ v y B Hvals Hctx IH]; constructor.
  - eapply val_rel_mono; done.
  - apply IH.
Qed.

(** *** Semantic typing judgment *)
Definition sem_typed Œî Œì e A :=
  ‚àÄ Œ∏ Œ¥ k, ùí¢ Œ¥ k Œì Œ∏ ‚Üí ‚Ñ∞ A Œ¥ k (subst_map Œ∏ e).
Notation "'TY' Œî ;  Œì ‚ä® e : A" := (sem_typed Œî Œì e A) (at level 74, e, A at next level).

Section boring_lemmas.
  (** The lemmas in this section are all quite boring and expected statements,
    but are quite technical to prove due to De Bruijn binders.
    We encourage to skip over the proofs of these lemmas.
  *)

  Lemma type_interp_ext  :
    ‚àÄ '(k, (B, c)), ‚àÄ Œ¥ Œ¥' x,
    (‚àÄ n k v, Œ¥ n k v ‚Üî Œ¥' n k v) ‚Üí
    type_interp c B Œ¥ k x ‚Üî type_interp c B Œ¥' k x.
  Proof.
    eapply (well_founded_ind (R := term_rel) term_rel_wf).
    intros (k & A & []) IH Œ¥ Œ¥'.
    { (* expression rel *)
      intros e Hd. simp type_interp. eapply forall_proper; intros e'.
      eapply forall_proper; intros n. eapply if_iff; first done.
      eapply if_iff; first done. f_equiv. intros v. f_equiv.
      eapply (IH ((k - n), (A, val_case))); last done.
      (* show that the induction is decreasing *)
      dsimpl.
    }
    intros v Hd. destruct A as [x | | | | A | A | A B | A B | A B | A ]; simp type_interp; eauto.
    - f_equiv; intros e. f_equiv. f_equiv.
      eapply forall_proper; intros œÑ.
      eapply (IH (_, (_, _))); first dsimpl.
      intros [|m] ?; simpl; eauto.
    - f_equiv; intros w. f_equiv. f_equiv. intros œÑ.
      eapply (IH (_, (_, _))); first dsimpl.
      intros [|m] ?; simpl; eauto.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv. eapply forall_proper. intros ?.
      eapply forall_proper. intros ?.
      eapply if_iff; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv; f_equiv; intros ?; f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - destruct k; simp type_interp.
      + done.
      + f_equiv; intros ?. f_equiv. f_equiv.
        eapply forall_proper; intros ?.
        by eapply (IH (_, (_, _))); first dsimpl.
  Qed.


  Lemma type_interp_move_ren :
    ‚àÄ '(k, (B, c)), ‚àÄ Œ¥ œÉ x, type_interp c B (Œª n, Œ¥ (œÉ n)) k x ‚Üî type_interp c (rename œÉ B) Œ¥ k x.
  Proof.
    eapply (well_founded_ind (R := term_rel) term_rel_wf).
    intros (k & A & []) IH Œ¥ œÉ.
    { (* expression rel *)
      intros e. simp type_interp. eapply forall_proper; intros e'.
      eapply forall_proper; intros n. eapply if_iff; first done.
      eapply if_iff; first done. f_equiv. intros v. f_equiv.
      eapply (IH (_, (_, _))).
      (* show that the induction is decreasing *)
      dsimpl.
    }
    intros v. destruct A as [x | | | | A | A | A B | A B | A B | A ]; simpl; simp type_interp; eauto.
    - f_equiv; intros e. f_equiv. f_equiv.
      eapply forall_proper; intros œÑ.
      etransitivity; last eapply (IH (_, (_, _))); last dsimpl.
      eapply (type_interp_ext (_, (_, _))).
      intros [|m] ?; simpl; eauto.
    - f_equiv; intros w. f_equiv. f_equiv. intros œÑ.
      etransitivity; last eapply (IH (_, (_, _))); last dsimpl.
      eapply (type_interp_ext (_, (_, _))).
      intros [|m] ?; simpl; eauto.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv. eapply forall_proper. intros ?.
      eapply forall_proper. intros ?.
      eapply if_iff; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv; f_equiv; intros ?; f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - destruct k; simp type_interp.
      + done.
      + f_equiv; intros ?. f_equiv. f_equiv.
        eapply forall_proper; intros ?.
        etransitivity; first eapply (IH (_, (_, _))); first dsimpl.
        (* NOTE: nice use of asimpl; :-) *)
        asimpl. done.
  Qed.


  Lemma type_interp_move_subst  :
    ‚àÄ '(k, (B, c)), ‚àÄ Œ¥ œÉ x, type_interp c B (Œª n, interp_type (œÉ n) Œ¥) k x ‚Üî type_interp c (B.[œÉ]) Œ¥ k x.
  Proof.
    eapply (well_founded_ind (R := term_rel) term_rel_wf).
    intros (k & A & []) IH Œ¥ œÉ.
    { (* expression rel *)
      intros e. simp type_interp. eapply forall_proper; intros e'.
      eapply forall_proper; intros n. eapply if_iff; first done.
      eapply if_iff; first done. f_equiv. intros v. f_equiv.
      eapply (IH (_, (_, _))).
      (* show that the induction is decreasing *)
      dsimpl.
    }
    intros v. destruct A as [x | | | | A | A | A B | A B | A B | A ]; simpl; simp type_interp; eauto.
    - f_equiv; intros e. f_equiv. f_equiv.
      eapply forall_proper; intros œÑ.
      etransitivity; last eapply (IH (_, (_, _))); last dsimpl.
      eapply (type_interp_ext (_, (_, _))).
      intros [|m] ? ?; simpl.
      + asimpl. simp type_interp. done.
      + unfold up; simpl. etransitivity;
          last eapply (type_interp_move_ren (_, (_, _))).
        done.
    - f_equiv; intros w. f_equiv. f_equiv. intros œÑ.
      etransitivity; last eapply (IH (_, (_, _))); last dsimpl.
      eapply (type_interp_ext (_, (_, _))).
      intros [|m] ? ?; simpl.
      + asimpl. simp type_interp. done.
      + unfold up; simpl. etransitivity;
          last eapply (type_interp_move_ren (_, (_, _))).
        done.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv. eapply forall_proper. intros ?.
      eapply forall_proper. intros ?.
      eapply if_iff; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv. intros ?. f_equiv. intros ?.
      f_equiv. f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - f_equiv; f_equiv; intros ?; f_equiv; by eapply (IH (_, (_, _))); first dsimpl.
    - destruct k; simp type_interp.
      + done.
      + f_equiv; intros ?. f_equiv. f_equiv.
        eapply forall_proper; intros ?.
        etransitivity; first eapply (IH (_, (_, _))); first dsimpl.
        (* NOTE: nice use of asimpl; :-) *)
        asimpl. done.
  Qed.


  Lemma sem_val_rel_move_single_subst A B Œ¥ k v :
    ùí± B (interp_type A Œ¥ .: Œ¥) k v ‚Üî ùí± (B.[A/]) Œ¥ k v.
  Proof.
    etransitivity; last eapply (type_interp_move_subst (_, (_, _))).
    eapply (type_interp_ext (_, (_, _))).
    intros [| n] ? w; simpl; simp type_interp; done.
  Qed.

  Lemma sem_expr_rel_move_single_subst A B Œ¥ k e :
    ‚Ñ∞ B (interp_type A Œ¥ .: Œ¥) k e ‚Üî ‚Ñ∞ (B.[A/]) Œ¥ k e.
  Proof.
    etransitivity; last eapply (type_interp_move_subst (_, (_, _))).
    eapply (type_interp_ext (_, (_, _))).
    intros [| n] ? w; simpl; simp type_interp; done.
  Qed.

  Lemma sem_val_rel_cons A Œ¥ k v œÑ :
    ùí± A Œ¥ k v ‚Üî ùí± A.[ren (+1)] (œÑ .: Œ¥) k v.
  Proof.
    etransitivity; last eapply (type_interp_move_subst (_, (_, _))).
    eapply (type_interp_ext (_, (_, _))).
    intros [| n] ? w; simpl; simp type_interp; done.
  Qed.

  Lemma sem_expr_rel_cons A Œ¥ k e œÑ :
    ‚Ñ∞ A Œ¥ k e ‚Üî ‚Ñ∞ A.[ren (+1)] (œÑ .: Œ¥) k e.
  Proof.
    etransitivity; last eapply (type_interp_move_subst (_, (_, _))).
    eapply (type_interp_ext (_, (_, _))).
    intros [| n] ? w; simpl; simp type_interp; done.
  Qed.


  Lemma sem_context_rel_cons Œì k Œ¥ Œ∏ œÑ :
    ùí¢ Œ¥ k Œì Œ∏ ‚Üí
    ùí¢ (œÑ .: Œ¥) k (‚§â Œì) Œ∏.
  Proof.
    induction 1 as [ | Œì Œ∏ v x A Hv Hctx IH]; simpl.
    - rewrite fmap_empty. constructor.
    - rewrite fmap_insert. constructor; last done.
      rewrite -sem_val_rel_cons. done.
  Qed.
End boring_lemmas.

(** Bind lemma *)
Lemma bind K e k Œ¥ A B :
  ‚Ñ∞ A Œ¥ k e ‚Üí
  (‚àÄ j v, j ‚â§ k ‚Üí ùí± A Œ¥ j v ‚Üí ‚Ñ∞ B Œ¥ j (fill K (of_val v))) ‚Üí
  ‚Ñ∞ B Œ¥ k (fill K e).
Proof.
  intros H1 H2. simp type_interp in H1. simp type_interp.
  intros e' n Hn (j & e'' & Hj & Hred1 & Hred2)%red_nsteps_fill.
  specialize (H1 e'' j ltac:(lia) Hred1) as (v & Hev & Hv).
  specialize (H2 (k-j) v ltac:(lia) Hv).
  simp type_interp in H2.
  rewrite (of_to_val _ _ Hev) in H2.
  eapply H2 in Hred2; last lia.
  assert (k - n = k - j - (n - j)) as -> by lia.
  done.
Qed.

(** This is the closure-under-expansion lemma from the lecture notes *)
Lemma expr_det_step_closure e e' A Œ¥ k :
  det_step e e' ‚Üí
  ‚Ñ∞ A Œ¥ (k - 1) e' ‚Üí
  ‚Ñ∞ A Œ¥ k e.
Proof.
  simp type_interp. intros Hdet Hexpr e'' n Hn [? Hred]%(det_step_red _ e'); last done.
  destruct (Hexpr e'' (n -1)) as (v & Hev & Hv); [lia | done | ].
  exists v. split; first done. replace (k - n) with (k - 1 - (n - 1)) by lia. done.
Qed.

Lemma expr_det_steps_closure e e' A Œ¥ k n :
  nsteps det_step n e e' ‚Üí ‚Ñ∞ A Œ¥ (k - n) e' ‚Üí ‚Ñ∞ A Œ¥ k e.
Proof.
  induction 1 as [ | n e1 e2 e3 Hstep Hsteps IH] in k |-* .
  - replace (k - 0) with k by lia. done.
  - intros He.
    eapply expr_det_step_closure; first done.
    apply IH. replace (k - 1 - n) with (k - (S n)) by lia. done.
Qed.

(** ** Compatibility lemmas *)

Lemma compat_int Œî Œì z : TY Œî; Œì ‚ä® (Lit $ LitInt z) : Int.
Proof.
  intros Œ∏ Œ¥ k _.
  eapply (sem_val_expr_rel _ _ _ #z).
  simp type_interp. eauto.
Qed.

Lemma compat_bool Œî Œì b : TY Œî; Œì ‚ä® (Lit $ LitBool b) : Bool.
Proof.
  intros Œ∏ Œ¥ k _.
  eapply (sem_val_expr_rel _ _ _ #b). simp type_interp. eauto.
Qed.

Lemma compat_unit Œî Œì : TY Œî; Œì ‚ä® (Lit $ LitUnit) : Unit.
Proof.
  intros Œ∏ Œ¥ k _.
  eapply (sem_val_expr_rel _ _ _ #LitUnit).
  simp type_interp. eauto.
Qed.

Lemma compat_var Œî Œì x A :
  Œì !! x = Some A ‚Üí
  TY Œî; Œì ‚ä® (Var x) : A.
Proof.
  intros Hx Œ∏ Œ¥ k Hctx; simpl.
  specialize (sem_context_rel_vals Hctx Hx) as (e & v & He & Heq & Hv).
  rewrite He. simp type_interp.
  rewrite -(of_to_val _ _ Heq).
  intros e' n Hn [-> ->]%nsteps_val_inv.
  rewrite to_of_val. eexists; split; first done.
  replace (k -0) with k by lia. done.
Qed.

Lemma compat_app Œî Œì e1 e2 A B :
  TY Œî; Œì ‚ä® e1 : (A ‚Üí B) ‚Üí
  TY Œî; Œì ‚ä® e2 : A ‚Üí
  TY Œî; Œì ‚ä® (e1 e2) : B.
Proof.
  intros Hfun Harg Œ∏ Œ¥ k Hctx; simpl.
  specialize (Hfun _ _ _ Hctx).
  specialize (Harg _ _ _ Hctx).

  eapply (bind [AppRCtx _]); first done.
  intros j v Hj Hv. simpl.

  eapply (bind [AppLCtx _ ]).
  { eapply expr_rel_mono; last done. lia. }
  intros j' f Hj' Hf.

  simp type_interp in Hf. destruct Hf as (x & e & -> & Hcl & Hf).
  specialize (Hf v 0).
  replace (j' - 0) with j' in Hf by lia.
  eapply expr_det_step_closure.
  { eapply det_step_beta. apply is_val_of_val. }
  eapply expr_rel_mono; last apply Hf; first lia.
  eapply val_rel_mono; last done. lia.
Qed.

Lemma is_closed_subst_map_delete X Œì (x: string) Œ∏ A e:
  closed X e ‚Üí
  subst_is_closed [] Œ∏ ‚Üí
  dom Œì ‚äÜ dom Œ∏ ‚Üí
  (‚àÄ y : string, y ‚àà X ‚Üí y ‚àà dom (<[x:=A]> Œì)) ‚Üí
  is_closed (x :b: []) (subst_map (delete x Œ∏) e).
Proof.
  intros He HŒ∏ Hdom1 Hdom2.
  eapply closed_subst_weaken; [ | | apply He].
  - eapply subst_is_closed_subseteq; last done.
    apply map_delete_subseteq.
  - intros y Hy%Hdom2 Hn. apply elem_of_list_singleton.
    apply not_elem_of_dom in Hn. apply elem_of_dom in Hy.
    destruct (decide (x = y)) as [<- | Hneq]; first done.
    rewrite lookup_delete_ne in Hn; last done.
    rewrite lookup_insert_ne in Hy; last done.
    move: Hdom1. rewrite elem_of_subseteq.
    move : Hn Hy. rewrite -elem_of_dom -not_elem_of_dom.
    naive_solver.
Qed.

(** Lambdas need to be closed by the context *)
Lemma compat_lam_named Œî Œì x e A B X :
  closed X e ‚Üí
  (‚àÄ y, y ‚àà X ‚Üí y ‚àà dom (<[x := A]> Œì)) ‚Üí
  TY Œî; (<[ x := A ]> Œì) ‚ä® e : B ‚Üí
  TY Œî; Œì ‚ä® (Lam (BNamed x) e) : (A ‚Üí B).
Proof.
  intros Hcl Hsub Hbody Œ∏ Œ¥ k Hctxt. simpl.
  eapply (sem_val_expr_rel _ _ _ (LamV x _)).
  simp type_interp.
  eexists (BNamed x), _. split_and!; [done| | ].
  { eapply is_closed_subst_map_delete; eauto.
    + eapply sem_context_rel_closed in Hctxt. naive_solver.
    + eapply sem_context_rel_subset in Hctxt; naive_solver.
  }

  intros v' kd Hv'.
  specialize (Hbody (<[ x := of_val v']> Œ∏) Œ¥ (k - kd)).
  simpl. rewrite subst_subst_map.
  2: { by eapply sem_context_rel_closed. }
  apply Hbody.
  apply sem_context_rel_insert; first done.
  eapply sem_context_rel_mono; last done. lia.
Qed.

Lemma is_closed_subst_map_anon X Œì Œ∏ e:
  closed X e ‚Üí
  subst_is_closed [] Œ∏ ‚Üí
  dom Œì ‚äÜ dom Œ∏ ‚Üí
  (‚àÄ y, y ‚àà X ‚Üí y ‚àà dom Œì) ‚Üí
  is_closed [] (subst_map Œ∏ e).
Proof.
  intros He HŒ∏ Hdom1 Hdom2.
  eapply closed_subst_weaken; [ | | apply He].
  - eapply subst_is_closed_subseteq; done.
  - intros y Hy%Hdom2 Hn.
    apply not_elem_of_dom in Hn. apply elem_of_dom in Hy.
    move: Hdom1. rewrite elem_of_subseteq.
    move : Hn Hy. rewrite -elem_of_dom -not_elem_of_dom.
    naive_solver.
Qed.

Lemma compat_lam_anon Œî Œì e A B X :
  closed X e ‚Üí
  (‚àÄ y, y ‚àà X ‚Üí y ‚àà dom Œì) ‚Üí
  TY Œî; Œì ‚ä® e : B ‚Üí
  TY Œî; Œì ‚ä® (Lam BAnon e) : (A ‚Üí B).
Proof.
  intros Hcl Hsub Hbody Œ∏ Œ¥ k Hctxt. simpl.
  eapply (sem_val_expr_rel _ _ _ (LamV BAnon _)).
  simp type_interp.
  eexists BAnon, _. split_and!; [done| | ].
  { eapply is_closed_subst_map_anon; eauto.
    + eapply sem_context_rel_closed in Hctxt. naive_solver.
    + eapply sem_context_rel_subset in Hctxt; naive_solver.
  }

  intros v' kd Hv'.
  apply (Hbody Œ∏ Œ¥ (k - kd)).
  eapply sem_context_rel_mono; last done. lia.
Qed.

Lemma compat_int_binop Œî Œì op e1 e2 :
  bin_op_typed op Int Int Int ‚Üí
  TY Œî; Œì ‚ä® e1 : Int ‚Üí
  TY Œî; Œì ‚ä® e2 : Int ‚Üí
  TY Œî; Œì ‚ä® (BinOp op e1 e2) : Int.
Proof.
  intros Hop He1 He2 Œ∏ Œ¥ k Hctx. simpl.
  specialize (He1 _ _ _ Hctx).
  specialize (He2 _ _ _ Hctx).

  eapply (bind [BinOpRCtx _ _]); first done.
  intros j v2 Hj Hv2. simpl.

  eapply (bind [BinOpLCtx _ _ ]).
  { eapply expr_rel_mono; last done. lia. }
  intros j' v1 Hj' Hv1.

  simp type_interp. intros e' n Hn Hred.
  simp type_interp in Hv1. simp type_interp in Hv2.
  destruct Hv1 as (z1 & ->). destruct Hv2 as (z2 & ->).

  inversion Hop; subst; simpl.
  all: eapply det_step_red in Hred as [ ? Hred]; [ |  eapply det_step_binop; done].
  all: apply nsteps_val_inv in Hred as [? ->].
  all: eexists; simpl; split; first done.
  all: simp type_interp; eauto.
Qed.

Lemma compat_int_bool_binop Œî Œì op e1 e2 :
  bin_op_typed op Int Int Bool ‚Üí
  TY Œî; Œì ‚ä® e1 : Int ‚Üí
  TY Œî; Œì ‚ä® e2 : Int ‚Üí
  TY Œî; Œì ‚ä® (BinOp op e1 e2) : Bool.
Proof.
  intros Hop He1 He2 Œ∏ Œ¥ k Hctx. simpl.
  specialize (He1 _ _ _ Hctx).
  specialize (He2 _ _ _ Hctx).

  eapply (bind [BinOpRCtx _ _]); first done.
  intros j v2 Hj Hv2. simpl.

  eapply (bind [BinOpLCtx _ _ ]).
  { eapply expr_rel_mono; last done. lia. }
  intros j' v1 Hj' Hv1.

  simp type_interp. intros e' n Hn Hred.
  simp type_interp in Hv1. simp type_interp in Hv2.
  destruct Hv1 as (z1 & ->). destruct Hv2 as (z2 & ->).

  inversion Hop; subst; simpl.
  all: eapply det_step_red in Hred as [ ? Hred]; [ |  eapply det_step_binop; done].
  all: apply nsteps_val_inv in Hred as [? ->].
  all: eexists; simpl; split; first done.
  all: simp type_interp; eauto.
Qed.

Lemma compat_unop Œî Œì op A B e :
  un_op_typed op A B ‚Üí
  TY Œî; Œì ‚ä® e : A ‚Üí
  TY Œî; Œì ‚ä® (UnOp op e) : B.
Proof.
  intros Hop He Œ∏ Œ¥ k Hctx. simpl.
  specialize (He _ _ _ Hctx).

  eapply (bind [UnOpCtx _]); first done.
  intros j v Hj Hv. simpl.

  simp type_interp. intros e' n Hn Hred.
  inversion Hop; subst.
  all: simp type_interp in Hv; destruct Hv as (? & ->).
  all: eapply det_step_red in Hred as [ ? Hred]; [ |  eapply det_step_unop; done].
  all: apply nsteps_val_inv in Hred as [? ->].
  all: eexists; simpl; split; first done.
  all: simp type_interp; eauto.
Qed.

Lemma compat_tlam Œî Œì e A X :
  closed X e ‚Üí
  (‚àÄ y, y ‚àà X ‚Üí y ‚àà dom Œì) ‚Üí
  TY S Œî; (‚§â Œì) ‚ä® e : A ‚Üí
  TY Œî; Œì ‚ä® (Œõ, e) : (‚àÄ: A).
Proof.
  intros Hcl Hsub He Œ∏ Œ¥ k Hctx. simpl.
  simp type_interp.
  intros e' n Hn Hred. eapply nsteps_val_inv' in Hred as [ -> ->]; last done.
  eexists; split; first done.
  simp type_interp.
  eexists _. split_and!; [ done | | ].
  { eapply is_closed_subst_map_anon; eauto.
    + eapply sem_context_rel_closed in Hctx; naive_solver.
    + eapply sem_context_rel_subset in Hctx; naive_solver.
  }

  intros œÑ. eapply He.
  replace (k -0) with k by lia. by eapply sem_context_rel_cons.
Qed.

Lemma compat_tapp Œî Œì e A B :
  type_wf Œî B ‚Üí
  TY Œî; Œì ‚ä® e : (‚àÄ: A) ‚Üí
  TY Œî; Œì ‚ä® (e <>) : (A.[B/]).
Proof.
  intros Hwf He Œ∏ Œ¥ k Hctx. simpl.

  specialize (He _ _ _ Hctx).
  eapply (bind [TAppCtx]); first done.
  intros j v Hj Hv.
  simp type_interp in Hv.
  destruct Hv as (e' & -> & ? & He').

  set (œÑ := interp_type B Œ¥).
  specialize (He' œÑ). simpl.
  eapply expr_det_step_closure.
  { apply det_step_tbeta. }
  eapply sem_expr_rel_move_single_subst.
  eapply expr_rel_mono; last done.
  lia.
Qed.

Lemma compat_pack Œî Œì e n A B :
  type_wf n B ‚Üí
  type_wf (S n) A ‚Üí
  TY n; Œì ‚ä® e : A.[B/] ‚Üí
  TY n; Œì ‚ä® (pack e) : (‚àÉ: A).
Proof.
  intros Hwf Hwf' He Œ∏ Œ¥ k Hctx. simpl.

  specialize (He _ _ _ Hctx).
  eapply (bind [PackCtx]); first done.
  intros j v Hj Hv.
  simpl. eapply (sem_val_expr_rel _ _ _ (PackV v)).
  simp type_interp. exists v; split; first done.
  exists (interp_type B Œ¥).
  apply sem_val_rel_move_single_subst. done.
Qed.

Lemma compat_unpack n Œì A B e e' x :
  type_wf n B ‚Üí
  TY n; Œì ‚ä® e : (‚àÉ: A) ‚Üí
  TY S n; <[x:=A]> (‚§âŒì) ‚ä® e' : B.[ren (+1)] ‚Üí
  TY n; Œì ‚ä® (unpack e as BNamed x in e') : B.
Proof.
  intros Hwf He He' Œ∏ Œ¥ k Hctx. simpl.

  specialize (He _ _ _ Hctx).
  eapply (bind [UnpackCtx _ _]); first done.
  intros j v Hj Hv.
  simp type_interp in Hv. destruct Hv as (v' & -> & œÑ & Hv').
  simpl.

  eapply expr_det_step_closure.
  { apply det_step_unpack. apply is_val_of_val. }
  simpl. rewrite subst_subst_map; last by eapply sem_context_rel_closed.

  specialize (He' (<[x := of_val v']> Œ∏) (œÑ.:Œ¥) (j - 1)).
  rewrite <-sem_expr_rel_cons in He'.
  apply He'.
  constructor.
  { eapply val_rel_mono; last done. lia. }
  apply sem_context_rel_cons.
  eapply sem_context_rel_mono; last done. lia.
Qed.

Lemma compat_if n Œì e0 e1 e2 A :
  TY n; Œì ‚ä® e0 : Bool ‚Üí
  TY n; Œì ‚ä® e1 : A ‚Üí
  TY n; Œì ‚ä® e2 : A ‚Üí
  TY n; Œì ‚ä® (if: e0 then e1 else e2) : A.
Proof.
  intros He0 He1 He2 Œ∏ Œ¥ k Hctx. simpl.
  specialize (He0 _ _ _ Hctx).
  specialize (He1 _ _ _ Hctx).
  specialize (He2 _ _ _ Hctx).

  eapply (bind [IfCtx _ _]); first done.
  intros j v Hj Hv.
  simp type_interp in Hv. destruct Hv as (b & ->).
  simpl.

  destruct b.
  - eapply expr_det_step_closure.
    { apply det_step_if_true. }
    eapply expr_rel_mono; last done. lia.
  - eapply expr_det_step_closure.
    { apply det_step_if_false. }
    eapply expr_rel_mono; last done. lia.
Qed.

Lemma compat_pair Œî Œì e1 e2 A B :
  TY Œî; Œì ‚ä® e1 : A ‚Üí
  TY Œî; Œì ‚ä® e2 : B ‚Üí
  TY Œî; Œì ‚ä® (e1, e2) : A √ó B.
Proof.
  intros He1 He2 Œ∏ Œ¥ k Hctx. simpl.
  specialize (He1 _ _ _ Hctx).
  specialize (He2 _ _ _ Hctx).

  eapply (bind [PairRCtx _]); first done.
  intros j v2 Hj Hv2.
  eapply (bind [PairLCtx _]).
  { eapply expr_rel_mono; last done. lia. }
  intros j' v1 Hj' Hv1.

  simpl.
  eapply (sem_val_expr_rel _ _ _ (v1, v2)%V).
  simp type_interp. exists v1, v2. split_and!; first done.
  - done.
  - eapply val_rel_mono; last done. lia.
Qed.

Lemma compat_fst Œî Œì e A B :
  TY Œî; Œì ‚ä® e : A √ó B ‚Üí
  TY Œî; Œì ‚ä® Fst e : A.
Proof.
  intros He Œ∏ Œ¥ k Hctx.
  specialize (He _ _ _ Hctx).
  simpl. eapply (bind [FstCtx]); first done.
  intros j v Hj Hv.
  simp type_interp in Hv. destruct Hv as (v1 & v2 & -> & Hv1 & Hv2).

  eapply expr_det_step_closure.
  { simpl. apply det_step_fst; apply is_val_of_val. }
  eapply sem_val_expr_rel. eapply val_rel_mono; last done. lia.
Qed.

Lemma compat_snd Œî Œì e A B :
  TY Œî; Œì ‚ä® e : A √ó B ‚Üí
  TY Œî; Œì ‚ä® Snd e : B.
Proof.
  intros He Œ∏ Œ¥ k Hctx.
  specialize (He _ _ _ Hctx).
  simpl. eapply (bind [SndCtx]); first done.
  intros j v Hj Hv.
  simp type_interp in Hv. destruct Hv as (v1 & v2 & -> & Hv1 & Hv2).

  eapply expr_det_step_closure.
  { simpl. apply det_step_snd; apply is_val_of_val. }
  eapply sem_val_expr_rel. eapply val_rel_mono; last done. lia.
Qed.

Lemma compat_injl Œî Œì e A B :
  TY Œî; Œì ‚ä® e : A ‚Üí
  TY Œî; Œì ‚ä® InjL e : A + B.
Proof.
  (* FIXME: exercise for you *)
(*Qed.*)
Admitted.

Lemma compat_injr Œî Œì e A B :
  TY Œî; Œì ‚ä® e : B ‚Üí
  TY Œî; Œì ‚ä® InjR e : A + B.
Proof.
  (* FIXME: exercise for you *)
(*Qed.*)
Admitted.

Lemma compat_case Œî Œì e e1 e2 A B C :
  TY Œî; Œì ‚ä® e : B + C ‚Üí
  TY Œî; Œì ‚ä® e1 : (B ‚Üí A) ‚Üí
  TY Œî; Œì ‚ä® e2 : (C ‚Üí A) ‚Üí
  TY Œî; Œì ‚ä® Case e e1 e2 : A.
Proof.
  (* FIXME: exercise for you *)
(*Qed.*)
Admitted.

Lemma compat_roll n Œì e A :
  TY n; Œì ‚ä® e : (A.[(Œº: A)%ty/]) ‚Üí
  TY n; Œì ‚ä® (roll e) : (Œº: A).
Proof.
  intros He Œ∏ Œ¥ k Hctx. simpl.
  specialize (He _ _ _ Hctx).

  eapply (bind [RollCtx]); first done.
  intros j v Hj Hv.
  eapply (sem_val_expr_rel _ _ _ (RollV v)).

  specialize (val_rel_is_closed _ _ _ _ Hv) as ?.
  destruct j as [ | j]; simp type_interp; first by eauto.
  exists v. split_and!; [done.. | ].
  intros kd. eapply val_rel_mono; last done. lia.
Qed.

Lemma compat_unroll n Œì e A :
  TY n; Œì ‚ä® e : (Œº: A) ‚Üí
  TY n; Œì ‚ä® (unroll e) : (A.[(Œº: A)%ty/]).
Proof.
  intros He Œ∏ Œ¥ k Hctx. simpl.
  specialize (He _ _ _ Hctx).

  eapply (bind [UnrollCtx]); first done.
  intros j v Hj Hv.
  destruct j as [ | j]; first by apply sem_expr_rel_zero_trivial.
  simp type_interp in Hv. destruct Hv as (v' & -> & ? & Hv).
  eapply expr_det_step_closure.
  { simpl. apply det_step_unroll. apply is_val_of_val. }
  eapply sem_val_expr_rel. apply Hv.
Qed.

Local Hint Resolve compat_var compat_lam_named compat_lam_anon compat_tlam compat_int compat_bool compat_unit compat_if compat_app compat_tapp compat_pack compat_unpack compat_int_binop compat_int_bool_binop compat_unop compat_pair compat_fst compat_snd compat_injl compat_injr compat_case compat_roll compat_unroll: core.

Lemma sem_soundness Œî Œì e A :
  TY Œî; Œì ‚ä¢ e : A ‚Üí
  TY Œî; Œì ‚ä® e : A.
Proof.
  induction 1 as [ | Œî Œì x e A B Hsyn IH | Œî Œì e A B Hsyn IH| Œî Œì e A Hsyn IH| | | | |  | | | | n Œì e1 e2 op A B C Hop ? ? ? ? | | | | | | | | | ]; eauto.
  - (* lambda *)
    set (X := elements (dom (<[x := A]>Œì))).
    specialize (syn_typed_closed _ _ _ _ X Hsyn) as Hcl.
    eapply compat_lam_named; last done.
    + apply Hcl. apply elem_of_elements.
    + intros ??. by apply elem_of_elements.
  - (* lambda anon *)
    set (X := elements (dom Œì)).
    specialize (syn_typed_closed _ _ _ _ X Hsyn) as Hcl.
    eapply compat_lam_anon; last done.
    + apply Hcl. apply elem_of_elements.
    + intros ??. by apply elem_of_elements.
  - (* tlam *)
    set (X := elements (dom Œì)).
    specialize (syn_typed_closed _ _ _ _ X Hsyn) as Hcl.
    eapply compat_tlam; last done.
    + apply Hcl. rewrite dom_fmap. apply elem_of_elements.
    + intros ??. by apply elem_of_elements.
  - (* binop *) inversion Hop; subst; eauto.
Qed.


(* dummy delta which we can use if we don't care *)
Program Definition any_type : sem_type := {| sem_type_car := Œª k v, is_closed [] v |}.
Definition Œ¥_any : var ‚Üí sem_type := Œª _, any_type.


Definition safe e :=
  ‚àÄ e' n, red_nsteps n e e' ‚Üí is_val e'.

Lemma type_safety e A :
  TY 0; ‚àÖ ‚ä¢ e : A ‚Üí
  safe e.
Proof.
  intros He%sem_soundness e' n Hred.
  specialize (He ‚àÖ Œ¥_any (S n)). simp type_interp in He.
  rewrite subst_map_empty in He.
  edestruct (He ) as (v & Hv & _); [ | | eassumption | ].
  - constructor.
  - lia.
  - rewrite <- (of_to_val _ _ Hv). apply is_val_of_val.
Qed.


(** Additional lemmas *)
Lemma semantic_app A B Œ¥ k e1 e2 :
  ‚Ñ∞ (A ‚Üí B) Œ¥ k e1 ‚Üí
  ‚Ñ∞ A Œ¥ k e2 ‚Üí
  ‚Ñ∞ B Œ¥ k (e1 e2).
Proof.
  intros He1 He2.
  eapply (bind [AppRCtx e1]); first done.
  intros j v Hj Hv. eapply (bind [AppLCtx _]).
  { eapply expr_rel_mono; last done. lia. }
  intros j' v' Hj' Hf.
  simp type_interp in Hf. destruct Hf as (x & e & -> & Hcl & Hf).
  eapply expr_det_step_closure.
  { apply det_step_beta. apply is_val_of_val. }
  apply Hf.
  eapply val_rel_mono; last done. lia.
Qed.
